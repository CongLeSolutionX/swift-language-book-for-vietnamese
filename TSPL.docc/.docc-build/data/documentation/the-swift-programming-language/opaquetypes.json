{"metadata":{"title":"Opaque and Boxed Types"},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"kind":"article","primaryContentSections":[{"content":[{"inlineContent":[{"type":"text","text":"Swift provides two ways to hide details about a value’s type:"},{"text":" ","type":"text"},{"text":"opaque types and boxed protocol types.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Hiding type information"},{"text":" ","type":"text"},{"text":"is useful at boundaries between","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a module and code that calls into the module,"},{"text":" ","type":"text"},{"type":"text","text":"because the underlying type of the return value can remain private."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A function or method that returns an opaque type"},{"text":" ","type":"text"},{"type":"text","text":"hides its return value’s type information."},{"type":"text","text":" "},{"text":"Instead of providing a concrete type as the function’s return type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the return value is described in terms of the protocols it supports."},{"type":"text","text":" "},{"type":"text","text":"Opaque types preserve type identity —"},{"type":"text","text":" "},{"type":"text","text":"the compiler has access to the type information,"},{"type":"text","text":" "},{"type":"text","text":"but clients of the module don’t."}],"type":"paragraph"},{"inlineContent":[{"text":"A boxed protocol type can store an instance of any type","type":"text"},{"type":"text","text":" "},{"text":"that conforms to the given protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Boxed protocol types don’t preserve type identity —"},{"text":" ","type":"text"},{"type":"text","text":"the value’s specific type isn’t known until runtime,"},{"text":" ","type":"text"},{"text":"and it can change over time as different values are stored.","type":"text"}],"type":"paragraph"},{"text":"The Problem That Opaque Types Solve","anchor":"The-Problem-That-Opaque-Types-Solve","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"For example,"},{"text":" ","type":"text"},{"text":"suppose you’re writing a module that draws ASCII art shapes.","type":"text"},{"text":" ","type":"text"},{"text":"The basic characteristic of an ASCII art shape","type":"text"},{"type":"text","text":" "},{"text":"is a ","type":"text"},{"code":"draw()","type":"codeVoice"},{"text":" function that returns the string representation of that shape,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which you can use as the requirement for the "},{"type":"codeVoice","code":"Shape"},{"text":" protocol:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["protocol Shape {","    func draw() -> String","}","","struct Triangle: Shape {","    var size: Int","    func draw() -> String {","       var result: [String] = []","       for length in 1...size {","           result.append(String(repeating: \"*\", count: length))","       }","       return result.joined(separator: \"\\n\")","    }","}","let smallTriangle = Triangle(size: 3)","print(smallTriangle.draw())","\/\/ *","\/\/ **","\/\/ ***"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You could use generics to implement operations like flipping a shape vertically,"},{"text":" ","type":"text"},{"type":"text","text":"as shown in the code below."},{"type":"text","text":" "},{"type":"text","text":"However, there’s an important limitation to this approach:"},{"type":"text","text":" "},{"type":"text","text":"The flipped result exposes the exact generic types"},{"type":"text","text":" "},{"type":"text","text":"that were used to create it."}]},{"code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}","let flippedTriangle = FlippedShape(shape: smallTriangle)","print(flippedTriangle.draw())","\/\/ ***","\/\/ **","\/\/ *"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This approach to defining a ","type":"text"},{"type":"codeVoice","code":"JoinedShape<T: Shape, U: Shape>"},{"text":" structure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that joins two shapes together vertically, like the code below shows,"},{"text":" ","type":"text"},{"type":"text","text":"results in types like "},{"code":"JoinedShape<FlippedShape<Triangle>, Triangle>","type":"codeVoice"},{"type":"text","text":" "},{"text":"from joining a flipped triangle with another triangle.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["struct JoinedShape<T: Shape, U: Shape>: Shape {","    var top: T","    var bottom: U","    func draw() -> String {","       return top.draw() + \"\\n\" + bottom.draw()","    }","}","let joinedTriangles = JoinedShape(top: smallTriangle, bottom: flippedTriangle)","print(joinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"]},{"type":"paragraph","inlineContent":[{"text":"Exposing detailed information about the creation of a shape","type":"text"},{"type":"text","text":" "},{"type":"text","text":"allows types that aren’t meant to be"},{"type":"text","text":" "},{"text":"part of the ASCII art module’s public interface","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to leak out because of the need to state the full return type."},{"type":"text","text":" "},{"type":"text","text":"The code inside the module"},{"text":" ","type":"text"},{"text":"could build up the same shape in a variety of ways,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and other code outside the module"},{"type":"text","text":" "},{"type":"text","text":"that uses the shape shouldn’t have to account for"},{"text":" ","type":"text"},{"type":"text","text":"the implementation details about the list of transformations."},{"type":"text","text":" "},{"text":"Wrapper types like ","type":"text"},{"code":"JoinedShape","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":" "},{"type":"text","text":"don’t matter to the module’s users,"},{"type":"text","text":" "},{"text":"and they shouldn’t be visible.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The module’s public interface"},{"text":" ","type":"text"},{"type":"text","text":"consists of operations like joining and flipping a shape,"},{"type":"text","text":" "},{"type":"text","text":"and those operations return another "},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" value."}]},{"level":2,"type":"heading","text":"Returning an Opaque Type","anchor":"Returning-an-Opaque-Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can think of an opaque type like being the reverse of a generic type."},{"type":"text","text":" "},{"text":"Generic types let the code that calls a function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"pick the type for that function’s parameters and return value"},{"type":"text","text":" "},{"type":"text","text":"in a way that’s abstracted away from the function implementation."},{"text":" ","type":"text"},{"type":"text","text":"For example, the function in the following code"},{"text":" ","type":"text"},{"type":"text","text":"returns a type that depends on its caller:"}]},{"syntax":"swift","code":["func max<T>(_ x: T, _ y: T) -> T where T: Comparable { ... }"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code that calls "},{"code":"max(_:_:)","type":"codeVoice"},{"type":"text","text":" chooses the values for "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and the type of those values determines the concrete type of "},{"type":"codeVoice","code":"T"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The calling code can use any type"},{"type":"text","text":" "},{"type":"text","text":"that conforms to the "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"text":"The code inside the function is written in a general way","type":"text"},{"type":"text","text":" "},{"type":"text","text":"so it can handle whatever type the caller provides."},{"type":"text","text":" "},{"text":"The implementation of ","type":"text"},{"type":"codeVoice","code":"max(_:_:)"},{"type":"text","text":" uses only functionality"},{"type":"text","text":" "},{"type":"text","text":"that all "},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":" types share."}]},{"inlineContent":[{"type":"text","text":"Those roles are reversed for a function with an opaque return type."},{"text":" ","type":"text"},{"text":"An opaque type lets the function implementation","type":"text"},{"type":"text","text":" "},{"type":"text","text":"pick the type for the value it returns"},{"type":"text","text":" "},{"type":"text","text":"in a way that’s abstracted away from the code that calls the function."},{"type":"text","text":" "},{"text":"For example, the function in the following example returns a trapezoid","type":"text"},{"type":"text","text":" "},{"type":"text","text":"without exposing the underlying type of that shape."}],"type":"paragraph"},{"code":["struct Square: Shape {","    var size: Int","    func draw() -> String {","        let line = String(repeating: \"*\", count: size)","        let result = Array<String>(repeating: line, count: size)","        return result.joined(separator: \"\\n\")","    }","}","","func makeTrapezoid() -> some Shape {","    let top = Triangle(size: 2)","    let middle = Square(size: 2)","    let bottom = FlippedShape(shape: top)","    let trapezoid = JoinedShape(","        top: top,","        bottom: JoinedShape(top: middle, bottom: bottom)","    )","    return trapezoid","}","let trapezoid = makeTrapezoid()","print(trapezoid.draw())","\/\/ *","\/\/ **","\/\/ **","\/\/ **","\/\/ **","\/\/ *"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":" function in this example"},{"text":" ","type":"text"},{"text":"declares its return type as ","type":"text"},{"code":"some Shape","type":"codeVoice"},{"text":";","type":"text"},{"text":" ","type":"text"},{"text":"as a result, the function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"returns a value of some given type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"text":" protocol,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"without specifying any particular concrete type."},{"text":" ","type":"text"},{"type":"text","text":"Writing "},{"type":"codeVoice","code":"makeTrapezoid()"},{"type":"text","text":" this way lets it express"},{"type":"text","text":" "},{"type":"text","text":"the fundamental aspect of its public interface —"},{"text":" ","type":"text"},{"text":"the value it returns is a shape —","type":"text"},{"text":" ","type":"text"},{"text":"without making the specific types that the shape is made from","type":"text"},{"type":"text","text":" "},{"text":"a part of its public interface.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This implementation uses two triangles and a square,"},{"type":"text","text":" "},{"text":"but the function could be rewritten to draw a trapezoid","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in a variety of other ways"},{"type":"text","text":" "},{"type":"text","text":"without changing its return type."}]},{"inlineContent":[{"type":"text","text":"This example highlights the way that an opaque return type"},{"type":"text","text":" "},{"type":"text","text":"is like the reverse of a generic type."},{"text":" ","type":"text"},{"type":"text","text":"The code inside "},{"code":"makeTrapezoid()","type":"codeVoice"},{"type":"text","text":" can return any type it needs to,"},{"text":" ","type":"text"},{"type":"text","text":"as long as that type conforms to the "},{"type":"codeVoice","code":"Shape"},{"text":" protocol,","type":"text"},{"text":" ","type":"text"},{"text":"like the calling code does for a generic function.","type":"text"},{"type":"text","text":" "},{"text":"The code that calls the function needs to be written in a general way,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"like the implementation of a generic function,"},{"text":" ","type":"text"},{"type":"text","text":"so that it can work with any "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" value"},{"text":" ","type":"text"},{"text":"that’s returned by ","type":"text"},{"type":"codeVoice","code":"makeTrapezoid()"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also combine opaque return types with generics."},{"text":" ","type":"text"},{"type":"text","text":"The functions in the following code both return a value"},{"text":" ","type":"text"},{"type":"text","text":"of some type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" protocol."}]},{"code":["func flip<T: Shape>(_ shape: T) -> some Shape {","    return FlippedShape(shape: shape)","}","func join<T: Shape, U: Shape>(_ top: T, _ bottom: U) -> some Shape {","    JoinedShape(top: top, bottom: bottom)","}","","let opaqueJoinedTriangles = join(smallTriangle, flip(smallTriangle))","print(opaqueJoinedTriangles.draw())","\/\/ *","\/\/ **","\/\/ ***","\/\/ ***","\/\/ **","\/\/ *"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The value of ","type":"text"},{"code":"opaqueJoinedTriangles","type":"codeVoice"},{"type":"text","text":" in this example"},{"type":"text","text":" "},{"type":"text","text":"is the same as "},{"type":"codeVoice","code":"joinedTriangles"},{"text":" in the generics example","type":"text"},{"text":" ","type":"text"},{"text":"in the ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","isActive":true},{"type":"text","text":" section earlier in this chapter."},{"type":"text","text":" "},{"text":"However, unlike the value in that example,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"flip(_:)"},{"text":" and ","type":"text"},{"code":"join(_:_:)","type":"codeVoice"},{"type":"text","text":" wrap the underlying types"},{"type":"text","text":" "},{"type":"text","text":"that the generic shape operations return"},{"type":"text","text":" "},{"text":"in an opaque return type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which prevents those types from being visible."},{"text":" ","type":"text"},{"text":"Both functions are generic because the types they rely on are generic,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and the type parameters to the function"},{"type":"text","text":" "},{"type":"text","text":"pass along the type information needed by "},{"code":"FlippedShape","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"JoinedShape"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a function with an opaque return type"},{"type":"text","text":" "},{"text":"returns from multiple places,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"all of the possible return values must have the same type."},{"type":"text","text":" "},{"type":"text","text":"For a generic function,"},{"type":"text","text":" "},{"type":"text","text":"that return type can use the function’s generic type parameters,"},{"text":" ","type":"text"},{"text":"but it must still be a single type.","type":"text"},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"text":"here’s an ","type":"text"},{"inlineContent":[{"type":"text","text":"invalid"}],"type":"emphasis"},{"text":" version of the shape-flipping function","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that includes a special case for squares:"}]},{"type":"codeListing","code":["func invalidFlip<T: Shape>(_ shape: T) -> some Shape {","    if shape is Square {","        return shape \/\/ Error: return types don't match","    }","    return FlippedShape(shape: shape) \/\/ Error: return types don't match","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you call this function with a "},{"type":"codeVoice","code":"Square"},{"text":", it returns a ","type":"text"},{"type":"codeVoice","code":"Square"},{"type":"text","text":";"},{"type":"text","text":" "},{"text":"otherwise, it returns a ","type":"text"},{"code":"FlippedShape","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This violates the requirement to return values of only one type"},{"type":"text","text":" "},{"type":"text","text":"and makes "},{"type":"codeVoice","code":"invalidFlip(_:)"},{"text":" invalid code.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"One way to fix "},{"code":"invalidFlip(_:)","type":"codeVoice"},{"text":" is to move the special case for squares","type":"text"},{"type":"text","text":" "},{"type":"text","text":"into the implementation of "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which lets this function always return a ","type":"text"},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":" value:"}]},{"syntax":"swift","type":"codeListing","code":["struct FlippedShape<T: Shape>: Shape {","    var shape: T","    func draw() -> String {","        if shape is Square {","           return shape.draw()","        }","        let lines = shape.draw().split(separator: \"\\n\")","        return lines.reversed().joined(separator: \"\\n\")","    }","}"]},{"inlineContent":[{"type":"text","text":"The requirement to always return a single type"},{"text":" ","type":"text"},{"text":"doesn’t prevent you from using generics in an opaque return type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Here’s an example of a function that incorporates its type parameter"},{"type":"text","text":" "},{"text":"into the underlying type of the value it returns:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["func `repeat`<T: Shape>(shape: T, count: Int) -> some Collection {","    return Array<T>(repeating: shape, count: count)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case,"},{"type":"text","text":" "},{"text":"the underlying type of the return value","type":"text"},{"type":"text","text":" "},{"text":"varies depending on ","type":"text"},{"code":"T","type":"codeVoice"},{"type":"text","text":":"},{"type":"text","text":" "},{"text":"Whatever shape is passed it,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"repeat(shape:count:)"},{"text":" creates and returns an array of that shape.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Nevertheless,"},{"type":"text","text":" "},{"text":"the return value always has the same underlying type of ","type":"text"},{"type":"codeVoice","code":"[T]"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"so it follows the requirement that functions with opaque return types"},{"type":"text","text":" "},{"type":"text","text":"must return values of only a single type."}]},{"level":2,"anchor":"Boxed-Protocol-Types","type":"heading","text":"Boxed Protocol Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A boxed protocol type is also sometimes called an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"existential type"}]},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which comes from the phrase","type":"text"},{"type":"text","text":" "},{"type":"text","text":"“there exists a type "},{"type":"emphasis","inlineContent":[{"type":"text","text":"T"}]},{"text":" such that ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"T"}]},{"type":"text","text":" conforms to the protocol”."},{"text":" ","type":"text"},{"text":"To make a boxed protocol type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"write "},{"type":"codeVoice","code":"any"},{"type":"text","text":" before the name of a protocol."},{"type":"text","text":" "},{"text":"Here’s an example:","type":"text"}]},{"syntax":"swift","code":["struct VerticalShapes: Shape {","    var shapes: [any Shape]","    func draw() -> String {","        return shapes.map { $0.draw() }.joined(separator: \"\\n\\n\")","    }","}","","let largeTriangle = Triangle(size: 5)","let largeSquare = Square(size: 5)","let vertical = VerticalShapes(shapes: [largeTriangle, largeSquare])","print(vertical.draw())"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"In the example above,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" declares the type of "},{"code":"shapes","type":"codeVoice"},{"text":" as ","type":"text"},{"code":"[any Shape]","type":"codeVoice"},{"type":"text","text":" —"},{"text":" ","type":"text"},{"text":"an array of boxed ","type":"text"},{"code":"Shape","type":"codeVoice"},{"text":" elements.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Each element in the array can be a different type,"},{"text":" ","type":"text"},{"type":"text","text":"and each of those types must conform to the "},{"type":"codeVoice","code":"Shape"},{"text":" protocol.","type":"text"},{"text":" ","type":"text"},{"text":"To support this runtime flexibility,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Swift adds a level of indirection when necessary —"},{"text":" ","type":"text"},{"text":"this indirection is called a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"box"}]},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"and it has a performance cost.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Within the ","type":"text"},{"type":"codeVoice","code":"VerticalShapes"},{"text":" type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the code can use methods, properties, and subscripts"},{"type":"text","text":" "},{"text":"that are required by the ","type":"text"},{"code":"Shape","type":"codeVoice"},{"type":"text","text":" protocol."},{"type":"text","text":" "},{"type":"text","text":"For example, the "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method of "},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" "},{"text":"calls the ","type":"text"},{"type":"codeVoice","code":"draw()"},{"text":" method on each element of the array.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This method is available because "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" requires a "},{"code":"draw()","type":"codeVoice"},{"type":"text","text":" method."},{"type":"text","text":" "},{"text":"In contrast,","type":"text"},{"text":" ","type":"text"},{"text":"trying to access the ","type":"text"},{"type":"codeVoice","code":"size"},{"type":"text","text":" property of the triangle,"},{"text":" ","type":"text"},{"text":"or any other properties or methods that aren’t required by ","type":"text"},{"code":"Shape","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"produces an error."}]},{"type":"paragraph","inlineContent":[{"text":"Contrast the three types you could use for ","type":"text"},{"code":"shapes","type":"codeVoice"},{"type":"text","text":":"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Using generics,"},{"text":" ","type":"text"},{"type":"text","text":"by writing "},{"type":"codeVoice","code":"struct VerticalShapes<S: Shape>"},{"type":"text","text":" and "},{"type":"codeVoice","code":"var shapes: [S]"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"makes an array whose elements are some specific shape type,"},{"text":" ","type":"text"},{"text":"and where the identity of that specific type","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is visible to any code that interacts with the array."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Using an opaque type,"},{"text":" ","type":"text"},{"text":"by writing ","type":"text"},{"code":"var shapes: [some Shape]","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"makes an array whose elements are some specific shape type,"},{"type":"text","text":" "},{"text":"and where that specific type’s identity is hidden.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Using a boxed protocol type,","type":"text"},{"text":" ","type":"text"},{"text":"by writing ","type":"text"},{"code":"var shapes: [any Shape]","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"makes an array that can store elements of different types,"},{"text":" ","type":"text"},{"type":"text","text":"and where those types’ identities are hidden."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case,"},{"text":" ","type":"text"},{"type":"text","text":"a boxed protocol type is the only approach"},{"text":" ","type":"text"},{"type":"text","text":"that lets callers of "},{"type":"codeVoice","code":"VerticalShapes"},{"type":"text","text":" mix different kinds of shapes together."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use an "},{"code":"as","type":"codeVoice"},{"type":"text","text":" cast"},{"type":"text","text":" "},{"type":"text","text":"when you know the underlying type of a boxed value."},{"type":"text","text":" "},{"type":"text","text":"For example:"}]},{"type":"codeListing","syntax":"swift","code":["if let downcastTriangle = vertical.shapes[0] as? Triangle {","    print(downcastTriangle.size)","}","\/\/ Prints \"5\""]},{"inlineContent":[{"text":"For more information, see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"level":2,"text":"Differences Between Opaque Types and Boxed Protocol Types","anchor":"Differences-Between-Opaque-Types-and-Boxed-Protocol-Types","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Returning an opaque type looks very similar","type":"text"},{"text":" ","type":"text"},{"text":"to using a boxed protocol type as the return type of a function,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but these two kinds of return type differ in"},{"type":"text","text":" "},{"text":"whether they preserve type identity.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"An opaque type refers to one specific type,"},{"type":"text","text":" "},{"type":"text","text":"although the caller of the function isn’t able to see which type;"},{"type":"text","text":" "},{"text":"a boxed protocol type can refer to any type that conforms to the protocol.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Generally speaking,"},{"type":"text","text":" "},{"type":"text","text":"boxed protocol types give you more flexibility"},{"text":" ","type":"text"},{"type":"text","text":"about the underlying types of the values they store,"},{"type":"text","text":" "},{"text":"and opaque types let you make stronger guarantees","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"about those underlying types."}]},{"type":"paragraph","inlineContent":[{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"here’s a version of "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":" "},{"type":"text","text":"that uses a boxed protocol type as its return type"},{"type":"text","text":" "},{"type":"text","text":"instead of an opaque return type:"}]},{"syntax":"swift","code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    return FlippedShape(shape: shape)","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This version of "},{"code":"protoFlip(_:)","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"has the same body as "},{"type":"codeVoice","code":"flip(_:)"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"and it always returns a value of the same type.","type":"text"},{"text":" ","type":"text"},{"text":"Unlike ","type":"text"},{"type":"codeVoice","code":"flip(_:)"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the value that "},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" returns isn’t required"},{"text":" ","type":"text"},{"text":"to always have the same type —","type":"text"},{"text":" ","type":"text"},{"text":"it just has to conform to the ","type":"text"},{"code":"Shape","type":"codeVoice"},{"text":" protocol.","type":"text"},{"text":" ","type":"text"},{"text":"Put another way,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" makes a much looser API contract with its caller"},{"type":"text","text":" "},{"type":"text","text":"than "},{"code":"flip(_:)","type":"codeVoice"},{"type":"text","text":" makes."},{"type":"text","text":" "},{"type":"text","text":"It reserves the flexibility to return values of multiple types:"}]},{"syntax":"swift","type":"codeListing","code":["func protoFlip<T: Shape>(_ shape: T) -> Shape {","    if shape is Square {","        return shape","    }","","    return FlippedShape(shape: shape)","}"]},{"type":"paragraph","inlineContent":[{"text":"The revised version of the code returns","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"an instance of "},{"code":"Square","type":"codeVoice"},{"type":"text","text":" or an instance of "},{"type":"codeVoice","code":"FlippedShape"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"depending on what shape is passed in."},{"type":"text","text":" "},{"text":"Two flipped shapes returned by this function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"might have completely different types."},{"type":"text","text":" "},{"type":"text","text":"Other valid versions of this function could return values of different types"},{"text":" ","type":"text"},{"type":"text","text":"when flipping multiple instances of the same shape."},{"type":"text","text":" "},{"type":"text","text":"The less specific return type information from "},{"code":"protoFlip(_:)","type":"codeVoice"},{"text":" means that","type":"text"},{"type":"text","text":" "},{"type":"text","text":"many operations that depend on type information"},{"type":"text","text":" "},{"text":"aren’t available on the returned value.","type":"text"},{"type":"text","text":" "},{"text":"For example, it’s not possible to write an ","type":"text"},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator"},{"type":"text","text":" "},{"text":"comparing results returned by this function.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let protoFlippedTriangle = protoFlip(smallTriangle)","let sameThing = protoFlip(smallTriangle)","protoFlippedTriangle == sameThing  \/\/ Error"]},{"inlineContent":[{"text":"The error on the last line of the example occurs for several reasons.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The immediate issue is that the "},{"type":"codeVoice","code":"Shape"},{"type":"text","text":" doesn’t include an "},{"type":"codeVoice","code":"=="},{"text":" operator","type":"text"},{"type":"text","text":" "},{"text":"as part of its protocol requirements.","type":"text"},{"type":"text","text":" "},{"text":"If you try adding one, the next issue you’ll encounter","type":"text"},{"type":"text","text":" "},{"text":"is that the ","type":"text"},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator needs to know"},{"type":"text","text":" "},{"text":"the types of its left-hand and right-hand arguments.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This sort of operator usually takes arguments of type "},{"type":"codeVoice","code":"Self"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"matching whatever concrete type adopts the protocol,"},{"type":"text","text":" "},{"type":"text","text":"but adding a "},{"code":"Self","type":"codeVoice"},{"text":" requirement to the protocol","type":"text"},{"type":"text","text":" "},{"text":"doesn’t allow for the type erasure that happens","type":"text"},{"type":"text","text":" "},{"type":"text","text":"when you use the protocol as a type."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using a boxed protocol type as the return type for a function"},{"type":"text","text":" "},{"text":"gives you the flexibility to return any type that conforms to the protocol.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"However, the cost of that flexibility"},{"text":" ","type":"text"},{"text":"is that some operations aren’t possible on the returned values.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The example shows how the "},{"type":"codeVoice","code":"=="},{"text":" operator isn’t available —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it depends on specific type information"},{"type":"text","text":" "},{"text":"that isn’t preserved by using a boxed protocol type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another problem with this approach is that the shape transformations don’t nest."},{"type":"text","text":" "},{"text":"The result of flipping a triangle is a value of type ","type":"text"},{"type":"codeVoice","code":"Shape"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"and the ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"type":"text","text":" function takes an argument"},{"text":" ","type":"text"},{"type":"text","text":"of some type that conforms to the "},{"type":"codeVoice","code":"Shape"},{"text":" protocol.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"However, a value of a boxed protocol type doesn’t conform to that protocol;"},{"text":" ","type":"text"},{"type":"text","text":"the value returned by "},{"code":"protoFlip(_:)","type":"codeVoice"},{"text":" doesn’t conform to ","type":"text"},{"type":"codeVoice","code":"Shape"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"This means code like ","type":"text"},{"type":"codeVoice","code":"protoFlip(protoFlip(smallTriangle))"},{"type":"text","text":" "},{"text":"that applies multiple transformations is invalid","type":"text"},{"text":" ","type":"text"},{"text":"because the flipped shape isn’t a valid argument to ","type":"text"},{"type":"codeVoice","code":"protoFlip(_:)"},{"text":".","type":"text"}]},{"inlineContent":[{"type":"text","text":"In contrast,"},{"text":" ","type":"text"},{"type":"text","text":"opaque types preserve the identity of the underlying type."},{"text":" ","type":"text"},{"type":"text","text":"Swift can infer associated types,"},{"text":" ","type":"text"},{"text":"which lets you use an opaque return value","type":"text"},{"type":"text","text":" "},{"text":"in places where a boxed protocol type can’t be used as a return value.","type":"text"},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"here’s a version of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol from "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","type":"reference","isActive":true},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol Container {","    associatedtype Item","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}","extension Array: Container { }"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"You can’t use "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" as the return type of a function"},{"type":"text","text":" "},{"text":"because that protocol has an associated type.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"You also can’t use it as constraint in a generic return type"},{"type":"text","text":" "},{"text":"because there isn’t enough information outside the function body","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to infer what the generic type needs to be."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Error: Protocol with associated types can't be used as a return type.","func makeProtocolContainer<T>(item: T) -> Container {","    return [item]","}","","\/\/ Error: Not enough information to infer C.","func makeProtocolContainer<T, C: Container>(item: T) -> C {","    return [item]","}"]},{"type":"paragraph","inlineContent":[{"text":"Using the opaque type ","type":"text"},{"code":"some Container","type":"codeVoice"},{"text":" as a return type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"expresses the desired API contract — the function returns a container,"},{"text":" ","type":"text"},{"type":"text","text":"but declines to specify the container’s type:"}]},{"code":["func makeOpaqueContainer<T>(item: T) -> some Container {","    return [item]","}","let opaqueContainer = makeOpaqueContainer(item: 12)","let twelve = opaqueContainer[0]","print(type(of: twelve))","\/\/ Prints \"Int\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The type of "},{"code":"twelve","type":"codeVoice"},{"type":"text","text":" is inferred to be "},{"type":"codeVoice","code":"Int"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which illustrates the fact that type inference works with opaque types."},{"text":" ","type":"text"},{"text":"In the implementation of ","type":"text"},{"code":"makeOpaqueContainer(item:)","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"the underlying type of the opaque container is ","type":"text"},{"type":"codeVoice","code":"[T]"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"In this case, "},{"code":"T","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"so the return value is an array of integers","type":"text"},{"type":"text","text":" "},{"text":"and the ","type":"text"},{"code":"Item","type":"codeVoice"},{"text":" associated type is inferred to be ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The subscript on "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" returns "},{"code":"Item","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which means that the type of "},{"type":"codeVoice","code":"twelve"},{"type":"text","text":" is also inferred to be "},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."}],"type":"paragraph"}],"kind":"content"}],"sections":[],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes","interfaceLanguage":"swift"},"abstract":[{"text":"Hide implementation details about a value’s type.","type":"text"}],"schemaVersion":{"patch":0,"minor":3,"major":0},"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"kind":"article","title":"The Swift Programming Language (5.9)","type":"topic","role":"collection","url":"\/documentation\/the-swift-programming-language","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/TypeCasting#Downcasting":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/TypeCasting#Downcasting","url":"\/documentation\/the-swift-programming-language\/typecasting#Downcasting","abstract":[],"kind":"section","type":"topic","title":"Downcasting"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Generics":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Generics","role":"article","abstract":[{"text":"Write code that works for multiple types and specify requirements for those types.","type":"text"}],"kind":"article","url":"\/documentation\/the-swift-programming-language\/generics","type":"topic","title":"Generics"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/OpaqueTypes#The-Problem-That-Opaque-Types-Solve":{"abstract":[],"title":"The Problem That Opaque Types Solve","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/OpaqueTypes#The-Problem-That-Opaque-Types-Solve","type":"topic","url":"\/documentation\/the-swift-programming-language\/opaquetypes#The-Problem-That-Opaque-Types-Solve"}}}